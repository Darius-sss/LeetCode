#### 1720--解码异或后的数组

**未知** 整数数组 `arr` 由 `n` 个非负整数组成。

经编码后变为长度为 `n - 1` 的另一个整数数组 `encoded` ，其中 `encoded[i] = arr[i] XOR arr[i + 1]` 。例如，`arr = [1,0,2,1]` 经编码后得到 `encoded = [1,2,3]` 。

给你编码后的数组 `encoded` 和原数组 `arr` 的第一个元素 `first`（`arr[0]`）。

请解码返回原数组 `arr` 。可以证明答案存在并且是唯一的。

 

**示例 1：**

```
输入：encoded = [1,2,3], first = 1
输出：[1,0,2,1]
解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]
```

**示例 2：**

```
输入：encoded = [6,2,7,3], first = 4
输出：[4,2,0,7,4]
```

 

**提示：**

- `2 <= n <= 10^4`
- `encoded.length == n - 1`
- `0 <= encoded[i] <= 10^5`
- `0 <= first <= 10^5`



##### 异或加密

```
class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for num in encoded:
            arr.append(num^arr[-1])
        return arr
```



#### 逻辑运算：

1、与（&），按位与运算符：参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0；

2、或（|），按位或运算符：只要对应的两个二进位有一个为1时，结果位就为1；

3、异或（^）,按位异或运算符：当两对应的二进位相异时，结果为1；

4、取反（~），按位取反运算符：对数据的每个二进制位取反，即把1变为0，把0变为1；

5、左位移（<<）,运算数的各二进位全部左移若干位，由<<右边的数字指定了移动的位数，高位丢弃，低位补0；

6、右位移（>>）,把‘>>’左边的运算数的各二进制位全部右移若干位，>>右边的数字指定了移动的位数。