#### 403. 青蛙过河

**【题目】**一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。

给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。

开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

##### 示例 1：

```
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
```


解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。

##### 示例 2：

```
输入：stones = [0,1,2,3,4,8,9,11]
输出：false
```


解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。

##### 提示：

`2 <= stones.length <= 2000`
`0 <= stones[i] <= 2^31 - 1`
`stones[0] == 0`



```
"""
动态规划： 
step1--创建二维列表保存状态：dp[当前节点][下一跨度]
step2--确定初始状态：dp[1][1]=True
step3--构建状态转移方程: 计算当前阶段的gap = stones[j]-stones[i]， 
       如果dp[i][gap-1] or dp[i][gap] or dp[i][gap+1] 则 dp[j][gap]=True
"""
class Solution:
    def canCross(self, stones):
        n = len(stones)
        # 与前一个点的距离不能大于当前下标+1
        # 如果存在大于的情况，则不可能到达终点
        for i in range(0, n-1):
            if stones[i+1] - stones[i] > i+1:
                return False

        # 状态表初始化
        dp = [[False for _ in range(n)] for _ in range(n)]

        # 确定初始状态
        dp[1][1] = True

        # 状态转移
        for i in range(2, n):
            for j in range(1, i):
                gap = stones[i] - stones[j]
                if gap <= j + 1:
                    dp[i][gap] = dp[j][gap - 1] or dp[j][gap] or dp[j][gap + 1]

        # 取结果
        for i in range(n):
            if dp[n-1][i]:
                return True
        return False 

```

##### 【思考】

1，为何需要与前一个点的距离不能大于当前下标+1？

2，为何初始化状态表可以为n行n列？

3，为何可以确认确定初始状态`dp[1][1] = True`?

4，状态转移的两个for循环为何从后往前？

5，状态转移方程的理解？

